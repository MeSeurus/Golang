**<p>Инструкция к выполнению</p>**
<p>1. Создайте абстракции (интерфейсы).</p>
<p>· Создайте интерфейсы RepositoryWriter и Notifier, которые будут определять общие контракты для всех типов баз данных и отправителей уведомлений.</p>
<p>2. Адаптируйте существующие структуры под интерфейсы.</p>
<p>· Выделите структуру EmailSender так, чтобы она реализовывала интерфейс Notifier. Для этого нужно перенести метод sendEmailNotification в нее и переименовать его в Send.</p>
<p>3. Добавьте новую функциональность.</p>
<p>· Создайте новую структуру SMSSender, которая также будет реализовывать интерфейс Notifier. Это продемонстрирует гибкость новой архитектуры.</p>
<p>4. Проведите рефакторинг основного сервиса.</p>
<p>· Создайте OrderService так, чтобы он зависел от интерфейсов RepositoryWriter и Notifier, а не от конкретных реализаций.</p>
<p>5. Продемонстрируйте работу.</p>
<p>· В функции main покажите, как можно использовать OrderService с разными типами отправителей (EmailSender и SMSSender), не меняя код самого сервиса.</p>
<p>6. Загрузите решение на GitHub</p>
<p>· Создайте новый публичный репозиторий на GitHub.</p>
<p>· Загрузите в него получившиеся файлы с итоговым решением.</p>
<p>Вставьте ссылку на вашу работу в поле «Ссылка на решение» и нажмите «Отправить на проверку». Перед отправкой домашнего задания вы можете написать комментарий эксперту.</p>

**Решено**

<p>SRP: Каждый класс решает конкретную задачу.</p>
<p>OCP: Добавляя новые виды нотификаторов или хранилищ, нам не придётся менять существующий код.</p>
<p>LSP: Новые реализации соответствуют существующему контракту интерфейса.</p>
<p>ISP: У каждого компонента есть минимальный, чётко определённый интерфейс.</p>
<p>DIP: order_service.go зависит от абстрактных интерфейсов, а не от конкретных классов.</p>
