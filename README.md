Описание задания
Вы разрабатываете модуль для анализа производительности веб-серверов. Ваша программа должна обработать большой список URL-адресов, имитируя отправку HTTP-запросов и замеряя время их выполнения.
Что необходимо сделать: Создайте программу на Go, которая:

Принимает список URL-адресов (можно задать в коде как слайс строк).
Параллельно обрабатывает каждый URL с помощью функции-заглушки, которая имитирует HTTP-запрос (используйте time.Sleep со случайной задержкой).
Собирает результаты обработки (URL, статус «обработан», время выполнения).
Выводит агрегированный отчёт по всем обработанным URL-адресам.
Ключевые требования:
● Для распараллеливания обработки URL должен использоваться паттерн Fan-out.
● Для сбора результатов от всех рабочих горутин (воркеров) должен использоваться паттерн Fan-in.
● Количество одновременно работающих воркеров должно быть ограничено (реализация Worker Pool).
● Программа должна корректно дожидаться завершения всех задач и выводить итоговый отчёт.
● Используйте каналы и sync.WaitGroup для синхронизации. Гонки данных должны быть исключены.
Инструкция к выполнению
Шаг 1: Подготовка структур данных
● Определите структуру Job для задания (например, с полями ID и URL).
● Определите структуру Result для результата (например, с полями Job, Status, Duration).
Шаг 2: Создайте функцию-воркер
● Функция должна принимать на вход канал для чтения заданий (<-chan Job), канал для записи результатов (chan<- Result) и *sync.WaitGroup.
● В функции используйте цикл for range по каналу с заданиями.
● Внутри цикла вызовите функцию-заглушку для имитации запроса (например, time.Sleep(randomDuration)).
● Отправьте результат обработки в канал результатов.
Шаг 3: Реализуйте паттерн Fan-out / Worker Pool
● В функции main создайте канал для заданий (jobs) и канал для результатов (results). Подумайте о необходимости их буферизации.
● Используя sync.WaitGroup, запустите фиксированное количество горутин-воркеров (например, 5). Каждая горутина должна выполнять функцию из Шага 2.
Шаг 4: Реализуйте паттерн Fan-in (сбор результатов)
● После запуска воркеров вам нужно отправить все задания в канал jobs и закрыть его, чтобы воркеры знали, когда остановиться.
● Запустите в отдельной горутине код, который с помощью wg.Wait() дождётся завершения всех воркеров и затем закроет канал results.
Шаг 5: Генерация заданий и агрегация результатов
● Наполните канал jobs заданиями на основе вашего списка URL.
● В главной горутине (в функции main) используйте цикл for range по каналу results, чтобы прочитать все результаты и, например, собрать их в слайс.
● Выведите финальный отчёт: список всех обработанных URL с их временем выполнения и общую статистику (например, среднее время, количество успешных операций).
Шаг 6: Проверка и рефакторинг
● Убедитесь, что программа завершается корректно, без deadlock’ов.
● Проверьте, что все задания были обработаны, и ни одно не было потеряно.
● Убедитесь, что вывод результатов читаем.
● Загрузите код в репозиторий на GitHub.
Вставьте ссылку на вашу работу в поле «Ссылка на решение» и нажмите «Отправить на проверку». Перед отправкой задания вы можете написать комментарий эксперту.

Критерии оценки задания:
«Зачёт»
● Программа успешно компилируется и выполняется без ошибок (паник или deadlock’ов).
● Реализованы и корректно работают паттерны Fan-out (распределение заданий по воркерам) и Fan-in (сбор результатов в одном канале).
● Количество одновременно работающих воркеров ограничено (Worker Pool).
● Использованы каналы и sync.WaitGroup для синхронизации, гонки данных отсутствуют.
● Все задания обрабатываются, и выводится читаемый отчёт.
● Код хорошо структурирован и читаем.
«На доработку»
● Программа не завершается или завершается с ошибками (паника, deadlock).
● Паттерны Fan-out/Fan-in реализованы не полностью или с ошибками (например, каналы не закрываются, что приводит к зависанию).
● Отсутствует ограничение на количество воркеров (запускается по горутине на каждое задание).
● В коде присутствуют гонки данных или иные проблемы синхронизации.
● Код плохо читается или структурирован.
«Незачёт» ставится в крайнем случае, если вы присылаете пустое или недоработанное задание во второй раз после отправки работы на доработку.